# InterviewTest

# شرح پروژه:
این پروژه یک سامانه درگاه پرداخت آزمایشی را شبیه سازی میکند که از 3 سرویس مجزا تشکیل شده است. سرویس payment که برای ثبت تراکنش ها و تاییدیه ها استفاده میشود. سرویس gateway که فرایند بانک را شبیه سازی میکند و سرویس notification که مامور ثبت لاگ و رسیدگی به event هاست

# معماری استفاده شده:
برای سرویس PaymentService از معماری CleanArchitecture استفاده شده که دارای 4 لایه Domain,Infrastructure,Application,Api می باشد.

سرویس GatewayService نیز از همین معماری استفاده کرده اما با توجه به اینکه نه ارتباطی با دیتابیس دارد و نه Domain خاصی دارد و صرفا ارتباط همزمان با PaymentService میگیرد، فقط لایه های Application,Api را در خود جای داده.

سرویس NotificationService نیز با توجه به اینکه نیازی به Api ندارد، صرفا یک ConsoleApplication است که consumer های RabbitMq را در خود جای داده. البته این سرویس هم میتوانست بصورت Api و CleanArchitecture پیاده سازی شود اما باتوجه به سایز و اهمیت آن، به همین میزان از طراحی بسنده شد


# تکنولوژیهای به کار رفته
برای ساخت سرویس های Payment , Gateway از Asp.Net WebApi با نسخه Net8. استفاده شده است.NotificationService نیز یک ConsoleApp نسخه  Net8. می باشد.

برای ارتباط با دیتابیس از efCore استفاده شده.

جهت جداسازی لایه Api از Application از MediatR14.0.0 استفاده گردیده.

از RabbitMq بعنوان MessageBroker در پروژه بهره بردیم. پیاده سازی آن به کمک MassTransit8.5.7 رخ داده است.

دیتابیس استفاده شده MSSqlServer می باشد. برای ساخت جداول نیز از migration بهره مند شدیم.

برای map کردن کلاس ها و Dto ها به یکدیگر از AutoMapper16.0 استفاده شده.

پکیچ Hangfire1.8.2 برای job های تکرار شونده درPaymentService مورد استفاده قرار گرفته.

نسخه 9.0.0 از پکیج Autofac برای مدیریت DI انتخاب گردیده است.


# نحوه راه اندازی و Migration

این پروژه برای اجرا شدن نیازمند .Net SDK 8 می باشد تا سرویس ها بالا بیایند.

در فایل appsettings.json از پروژه PaymentService لازم است connectionString مربوط به دیتابیس وارد شود.

آدرس های localhost:5001 و localhost:5002 برای Api ها ست شده اند. چنانچه این آدرس ها را تغییر دادید یا در هاست واقعی اجرا نمودید لازم است appsettings.json هر دو سرویس را ویرایش کرده و Url های مناسب را قرار دهید.

برای راه اندازی RabbitMq از فایل rabbitmq-server-4.2.0.exe استفاده شده که بصورت خودکار سرویس rabbit را اجرا نموده و یک داشبورد مناسب نیز در اختیار قرار می دهد. این فایل در root پروژه قرار داده شده است.

# معماری و تصمیمات طراحی

با توجه به فرض مسئله، همه سرویس ها می بایست در یک solution قرار میگرفتند. برای اینکه معماری Clean رعایت بشه هم میشد از فولدر بندی استفاده کرد و هم میشد هر لایه رو در یک پروژه مجزا ثبت کرد. مزیت مورد اول این بود که هر سرویس فقط یک پروژه داشت و solution تمیز تر و یکپارچه تر بود. اما با توجه به اینکه در این حالت دسترسی لایه ها به یکدیگر باز میشد و ممکن بود ناخواسته رفرنس های اشتباه زده بشه تصمیم گرفتم هر لایه از هر سرویس تبدیل به یک پروژه بشه که دسترسی ها کنترل شده اعمال بشه. برای تفکیک و اشتباه نشدن لایه ها هم از اسم سرویس نقطه نام لایه استفاده کردم.

همچنین یک پروژه class Library به نام Share اضافه شد که کلاس های مشترک بین همه سرویس ها در داخل اون قرار بگیره.

در PaymentService: دلیل استفاده از معماری Clean این است که جداسازی لایه ها از یکدیگر به خوبی و به راحتی انجام میشود. تست هر لایه بطور جداگانه قابل انجام است. تکفیف وضایف به خوبی انجام میشود. پیچیدگی خاصی ندارد و توسعه و نگه داری آن راحت هست. همچنین هر لایه میتواند از پروژه جدا شده و یک لایه جدید با تکنولوژی جدید جایگزین آن گردد.

در GatewayService نیز از همین معماری استفاده شده اما با توجه به نداشتن دیتابیس و Domain خاصی، از لایه Domain و Infrastructure صرف نظر کردم. صرفا با Api و Application کار کردم که البته اگر قرار باشه خیلی به قرارداد ها پایبند باشیم، اسم این معماری بجای Clean ، معماری multi layer خواهد بود.

در NotificationService هم صرفا به یک consoleApp بسنده کردم چون نیازی نبود کد های اضافی نوشته بشه تا صرفا ساختار clean رعایت بشه. تا وقتی نیازی نیست، باید از زیاده نویسی پرهیز کرد. این سرویس صرفا قرار بود مصرف کننده پیام های Rabbit باشه که الان هم دقیقا همین هست. با توجه به اینکه business ویژه ای هم براش ذکر نشده بود، همین تک پروژه براش کافی بود.

**چالش های پیاده سازی: بعضا ورژن ابزار ها و تکنولوژی ها تغییراتی کرده بود یا سازگاری با .Net8 نداشت که مجبور بودم پکیج ها رو عوض کنم یا از روش های دیگری برای حل ارور ها استفاده کنم.

توضیحات داده شده در متن سوال در جاهای خیلی کمی، نا مفهوم بود که باعث شد خودم تغییراتی در متغیر ها یا روند ها بدم. البته این موضوع خیلی پر  رنگ نبود.

**اگر زمان بیشتری داشتم: - حتما از autoFac به نحو بهتری استفاده میکردم. البته پروژه خیلی کوچیک بود و شاید حتی لازم نبود از این پکیج استفاده بشه اما به دید دراز مدت حتما لازم بود که فرایند رجیستر شدن کلاس ها در DI به طرز خودکار انجام بشه.

- هیچ سیستمی نیست که به کش نیاز نداشته باشه. اگر وقت بیشتری داشتم حتما سعی میکردم لااقل کشینگ رو به سامانه اضافه کنم که بعده ها بشه ازش استفاده کرد.
- برای تعریف کلاس ها و هندلر ها و ... از GenericType ها استفاده میکردم که زمان کد نویسی و خواناییش رو بالاتر ببره.
- هرچند به طور ناخودآکاه این موارد رو رعایت کردم اما اگر زمان بیشتر و فورس ذهنی کمتری داشتم از امکانات زبان c# مثل loc و memory management و span و .... استفاده میکردم. خیلی تو این پروژه جاش نبود اما اگه پروژه بزرگ بشه استفاده از این ها به شدت به کارایی سیستم کمک میکنه
